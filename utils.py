# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QTApXMx4_5wmCexh_jdeJQNl7ZK4AgiG

# Plot Image function
"""

import matplotlib.pyplot as plt
import numpy as np
import random
import torch
import seaborn as sns
from sklearn.metrics import confusion_matrix

def plot_image(x_train, y_train, figsize=(10, 7), rows=5, cols=5, cmap="gray_r"):
    """
    Plots a grid of images with their corresponding labels.

    Parameters:
    x_train (numpy.ndarray or torch.Tensor): Array of image data.
    y_train (numpy.ndarray or torch.Tensor): Array of labels corresponding to the image data.
    figsize (tuple): Size of the figure.
    rows (int): Number of rows in the grid.
    cols (int): Number of columns in the grid.
    cmap (str): Colormap to be used for plotting images.

    Example usage:
    --------------
    >>> transform = transforms.Compose([transforms.ToTensor()])
    >>> train_dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transform)
    >>> train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=60000, shuffle=True)
    >>> for images, labels in train_loader:
    >>>     x_train, y_train = images, labels
    >>> plot_image(x_train, y_train, figsize=(12, 8), rows=4, cols=6, cmap="gray_r")

    """
    plt.figure(figsize=figsize)
    for i in range(1, rows * cols + 1):
        # Select a random index from the dataset
        random_index = random.randint(0, len(x_train) - 1)
        plt.subplot(rows, cols, i)
        img = x_train[random_index]

        if isinstance(img, torch.Tensor):
            img = img.numpy()  # Convert torch.Tensor to numpy array if needed

        if img.ndim == 3 and img.shape[0] in [1, 3]:  # Handle channels-first format
            img = np.transpose(img, (1, 2, 0))  # Convert to channels-last format

        plt.imshow(img.squeeze() if img.shape[-1] == 1 else img, cmap=cmap if img.shape[-1] == 1 else None)  # Squeeze for single-channel
        plt.title(str(y_train[random_index].item() if isinstance(y_train[random_index], torch.Tensor) else y_train[random_index]))  # Convert label to string
        plt.axis("off")  # Hide axes for a cleaner look
    plt.show()

"""# plot the loss curves"""

def plot_curves(history, loss_key="loss", val_loss_key="val_loss", acc_key="accuracy", val_acc_key="val_accuracy"):
    """
    Plots training and validation loss and accuracy curves.

    Args:
    history: History object containing training history, typically returned by the fit method of a model.
    loss_key (str): Key for training loss in the history object.
    val_loss_key (str): Key for validation loss in the history object.
    acc_key (str): Key for training accuracy in the history object.
    val_acc_key (str): Key for validation accuracy in the history object.

    Example usage:
    --------------
    >>> plot_curves(history)
    """
    loss = history.history[loss_key]
    val_loss = history.history[val_loss_key]
    acc = history.history[acc_key]
    val_acc = history.history[val_acc_key]

    epochs = range(1, len(loss) + 1)

    plt.figure(figsize=(14, 5))

    # Plot loss
    plt.subplot(1, 2, 1)
    plt.plot(epochs, loss, label="Training loss")
    plt.plot(epochs, val_loss, label="Validation loss")
    plt.title("Training and Validation Loss")
    plt.xlabel("Epochs")
    plt.ylabel("Loss")
    plt.legend()

    # Plot accuracy
    plt.subplot(1, 2, 2)
    plt.plot(epochs, acc, label="Training accuracy")
    plt.plot(epochs, val_acc, label="Validation accuracy")
    plt.title("Training and Validation Accuracy")
    plt.xlabel("Epochs")
    plt.ylabel("Accuracy")
    plt.legend()

    plt.tight_layout()
    plt.show()

def plot_correctly_classified_images(model, X_test, y_test, predict_fn, num_images=25):
    """
    Plots correctly classified images from the test set.

    Args:
        model (object): The trained model used for predictions.
        X_test (np.ndarray): The test set features.
        y_test (np.ndarray): The test set true labels.
        predict_fn (callable): A function that takes the model and X_test as input and returns the predicted labels.
        num_images (int): The number of correctly classified images to plot. Default is 25.

    Raises:
        ValueError: If the model is not a supported type.

    Example usage:
    --------------
        # TensorFlow model example
        def tensorflow_predict(model, X):
            return model.predict(X)

        plot_correctly_classified_images(model, X_test, y_test, tensorflow_predict)
    """
    # Get predictions using the custom prediction function
    pred_labels = np.argmax(predict_fn(model, X_test), axis=1)
    true_labels = np.argmax(y_test, axis=1)

    # Identify correctly classified images
    correctly_classified_indices = np.where(pred_labels == true_labels)[0]
    print(f"There are {len(correctly_classified_indices)} correctly classified images")

    # If there are fewer than num_images correctly classified images, adjust num_images
    if len(correctly_classified_indices) < num_images:
        num_images = len(correctly_classified_indices)

    # Randomly select num_images correctly classified indices
    selected_indices = random.sample(list(correctly_classified_indices), num_images)

    # Calculate the number of rows and columns for the plot
    num_rows = num_cols = int(np.sqrt(num_images))

    # Create a figure for the plot
    fig, axes = plt.subplots(num_rows, num_cols, figsize=(12, 12))

    # Loop through the indices and plot each image
    for i, idx in enumerate(selected_indices):
        ax = axes[i // num_cols, i % num_cols]
        image = X_test[idx].reshape((X_test.shape[1], X_test.shape[2]))
        true_label = true_labels[idx]
        pred_label = pred_labels[idx]

        ax.imshow(image, cmap='gray')
        ax.set_title(f"Pred: {pred_label}\nTrue: {true_label}")
        ax.axis('off')
    plt.tight_layout()
    plt.show()

"""# Plot misclassification"""

def plot_misclassified_images(model, X_test, y_test, predict_fn, num_images=25):
    """
    Plots misclassified images from the test set.

    Args:
        model (object): The trained model used for predictions.
        X_test (np.ndarray): The test set features.
        y_test (np.ndarray): The test set true labels.
        predict_fn (callable): A function that takes the model and X_test as input and returns the predicted labels.
        num_images (int): The number of misclassified images to plot. Default is 25.

    Raises:
        ValueError: If the model is not a supported type.

    Example usage:
    --------------
        # TensorFlow model example
        def tensorflow_predict(model, X):
            return model.predict(X)

        plot_misclassified_images(model, X_test, y_test, tensorflow_predict)
    """
    # Get predictions using the custom prediction function
    pred_labels = np.argmax(predict_fn(model, X_test), axis=1)
    true_labels = np.argmax(y_test, axis=1)

    # Identify misclassified images
    misclassified_indices = np.where(pred_labels != true_labels)[0]
    print(f"There are {len(misclassified_indices)} misclassified images")

    # If there are fewer than num_images misclassified images, adjust num_images
    if len(misclassified_indices) < num_images:
        num_images = len(misclassified_indices)

    # Randomly select num_images misclassified indices
    selected_indices = random.sample(list(misclassified_indices), num_images)

    # Calculate the number of rows and columns for the plot
    num_rows = num_cols = int(np.sqrt(num_images))

    # Create a figure for the plot
    fig, axes = plt.subplots(num_rows, num_cols, figsize=(12, 12))

    # Loop through the indices and plot each image
    for i, idx in enumerate(selected_indices):
        ax = axes[i // num_cols, i % num_cols]
        image = X_test[idx].reshape((X_test.shape[1], X_test.shape[2]))
        true_label = true_labels[idx]
        pred_label = pred_labels[idx]

        ax.imshow(image, cmap='gray')
        ax.set_title(f"Pred: {pred_label}\nTrue: {true_label}")
        ax.axis('off')
    plt.tight_layout()
    plt.show()

def plot_confusion_matrix(model, X_test, y_test, file_path):
    """
    Plot and save the confusion matrix for a given model and test dataset.

    Parameters:
    model : keras.Model or any model with a predict method
        Trained model to be evaluated.
    X_test : np.ndarray
        Test data features.
    y_test : np.ndarray
        True labels for the test data, assumed to be one-hot encoded.
    file_path : str
        Path to save the plotted confusion matrix image.

    Example Usage:
    --------
    plot_confusion_matrix(model, X_test, y_test, "confusion_matrix.png")
    """

    # Predict the labels for the test set
    y_pred = np.argmax(model.predict(X_test), axis=1)
    y_true = np.argmax(y_test, axis=1)

    # Compute the confusion matrix
    confusion_mat = confusion_matrix(y_true, y_pred)

    # Get class names from the unique values in y_test
    class_names = [f"Class {i}" for i in range(y_test.shape[1])]

    # Create a heatmap for the confusion matrix
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_mat, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
    plt.xlabel('Predicted Labels')
    plt.ylabel('True Labels')
    plt.title('Confusion Matrix')

    # Save the plot as an image file
    plt.savefig(file_path)
    plt.show()